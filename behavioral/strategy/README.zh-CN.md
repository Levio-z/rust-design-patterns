# 策略模式（Strategy Pattern） - Rust 实现说明

## 一、概念重述

策略模式将一族算法独立封装，使得它们可以相互替换，且不会影响使用它们的代码逻辑。  
该模式满足开闭原则（OCP）与依赖倒置原则（DIP），常用于行为变化的封装。

---

## 二、Rust 实现核心要点

Rust 没有传统面向对象语言的接口机制，但可以通过 `trait`（特征）来定义策略接口，实现策略模式的核心思想。

### ✅ 策略对象的两类形态

#### 1. 无状态策略（Stateless）

- 不包含任何字段，只执行纯粹逻辑；
- 可缓存、复用，无线程安全问题。

#### 2. 有状态策略（Stateful）

- 包含成员变量，如路径、配置、因子等；
- 每次需实例化，避免状态污染或并发问题。

### ✅ 策略动态分发

使用 `Box<dyn Trait>` 进行运行时策略替换，适合策略来源不确定、用户配置场景。

---

## 三、应用建议

| 场景 | 示例 | 是否适合使用 |
|------|------|--------------|
| 行为需动态切换 | 支付方式、日志输出、折扣逻辑 | ✅ |
| 行为多样但结构稳定 | 路线规划、图片压缩 | ✅ |
| 大量 if-else 或 match | 资源处理器、事件调度器 | ✅ |

---

## 四、总结

Rust 策略模式实现的本质是：  
使用 `trait` 定义统一行为接口，用结构体实现策略细节，通过泛型或 trait object 进行灵活注入。

## Todo
- 有状态策略 