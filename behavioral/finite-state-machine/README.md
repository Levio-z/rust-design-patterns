# Rust 状态模式（State Pattern）实现方式

状态模式是一种行为型设计模式，允许对象在内部状态改变时改变其行为。它将状态封装成独立的结构体或模块，使得状态之间的切换更加清晰，职责更明确，逻辑更解耦。

本项目展示了 Rust 中状态模式的三种典型实现方式，以及一种混合实现，适用于不同复杂度的状态系统。

### 实现方式总览

| 实现方式                     | 风格           | 特点                     | 适用场景                                |
|------------------------------|----------------|--------------------------|-----------------------------------------|
| 方式一：Trait + Box\<dyn>    | 面向对象       | 高度封装、逻辑分离       | 状态行为复杂、对象职责明确的场景        |
| 方式二：状态枚举 + match     | 函数式风格     | 简洁清晰、性能优         | 状态有限、切换逻辑简单的系统            |
| 方式三：查表法（二维数组）   | 配置驱动       | 易于维护、适配配置文件   | 状态多、事件多、转移频繁的场景          |
| 方式四：查表法 + 状态模式    | 混合架构       | 数据集中、行为封装       | 状态多、副作用复杂、需要可组合行为的系统 |

---

### 示例背景：Mario 状态机

该状态机模拟一个马里奥游戏人物状态的变更过程。

状态包括：

- Small：普通状态
- Super：吃蘑菇变大
- Cape：获得斗篷飞行
- Fire：获得火球攻击

事件包括：

- obtain_mushroom：吃蘑菇
- obtain_cape：吃斗篷
- obtain_fire_flower：吃火花
- meet_monster：遇敌受伤

状态行为的本质是状态转移加上积分变更（或执行副作用动作）。

状态转移表如下：

| 当前状态 | E1: Mushroom       | E2: Cape          | E3: Fire Flower    | E4: Monster      |
|----------|--------------------|-------------------|--------------------|------------------|
| Small    | Super / +100       | Cape / +200       | Fire / +300        | 无变化           |
| Super    | Super / 0          | Cape / +200       | Fire / +300        | Small / -100     |
| Cape     | Cape / 0           | Cape / 0          | Cape / 0           | Small / -200     |
| Fire     | Fire / 0           | Fire / 0          | Fire / 0           | Small / -300     |

---

### 实现一：状态机（state-machine）

该实现方式采用面向对象风格，为每个状态定义一个结构体，实现统一的 trait 接口。每个状态类持有状态变更逻辑，并通过状态机传入自身上下文实现转移。

优点：

- 职责分离清晰，易于扩展和维护；
- 支持每个状态自定义行为。

缺点：

- 存在运行期动态分发的开销；
- 相较其他方式结构更复杂，代码量更大。

适合场景：

- 状态转移逻辑简单但行为复杂的系统。

---

### 实现二：状态枚举 + match 分支（enum-match）

该实现使用枚举表示所有状态，状态行为统一写在状态机中。通过 match 分支处理每个事件下的状态转移逻辑。

优点：

- 实现简单、结构紧凑、效率高；
- 易于快速原型开发。

缺点：

- 难以扩展，违反开闭原则；
- 行为与状态逻辑耦合度高。

适合场景：

- 状态数量有限；
- 状态行为清晰、变更频率低的项目。

---

### 实现三：查表法（transition-table）

该实现将状态转移关系和积分变更行为编码为两个二维数组，分别为 `transition_table` 和 `action_table`。事件触发时查表完成状态转移和积分变化。

优点：

- 状态转移逻辑清晰、集中；
- 适合与配置文件（如 YAML / JSON / DSL）集成；
- 易于维护、扩展状态集。

缺点：

- 不支持副作用逻辑（如打印、日志、UI 控制等）；
- 系统行为高度受限于查表定义。

适合场景：

- 状态与事件种类繁多；
- 行为简单、结构规则性强的系统；
- 需要配置驱动逻辑的自动机。

---

### 实现四：查表法 + 状态模式（transition-table-machine）

该实现结合查表法与状态模式的优势，分离状态迁移数据与行为逻辑：

- 使用 `TRANSITIONS` 和 `SCORES` 管理状态变迁与积分；
- 使用 `MarioState` trait 封装每个状态对应的副作用逻辑；
- 状态行为通过动态分发实现灵活调用。

事件处理流程：

1. 当前状态执行自身行为（如打印日志）；
2. 状态机通过查表获取新状态与得分；
3. 更新当前状态与积分。

优点：

- 状态数据与行为逻辑彻底分离；
- 状态行为可组合、可测试；
- 支持热切换数据表（配置热更新）。

缺点：

- 实现复杂度相对较高；
- 行为中需要上下文注入时需额外设计支持。

适合场景：

- 状态与事件多样，行为复杂度中等；
- 需要可视化、配置化与副作用结合的状态系统；
- 游戏系统、UI 动画系统、交易流程建模等。

---

### 实现方式对比与推荐

| 实现方式                 | 封装性 | 可扩展性 | 性能 | 难度 | 推荐使用场景                                       |
|--------------------------|--------|----------|------|------|----------------------------------------------------|
| Trait + Box              | 高     | 高       | 中等 | 中   | 行为复杂、逻辑分离需求强                           |
| 枚举 + match             | 低     | 低       | 高   | 低   | 状态数量有限，逻辑简单                             |
| 查表法                   | 中     | 中       | 高   | 低   | 状态事件多但逻辑统一、数据驱动系统                 |
| 查表法 + 状态模式        | 高     | 高       | 高   | 中   | 状态/事件多，副作用复杂但逻辑可配置、可组合的系统 |

---

